<?xml version="1.0" encoding="UTF-8" ?>
<dt-api group="cells">
	<name>cells().every()</name>
	<summary>Iterate over each selected cell, with the function context set to be the cell in question.</summary>
	<since>1.10.6</since>

	<type type="function">
		<signature>cells().every( fn )</signature>
		<description>Iterate over each selected cell, with the function context set to be the cell in question. This function is not passed any parameters and no return value is expected.</description>
		<returns type="DataTables.Api">DataTables API instance of the selected cells.</returns>
	</type>

	<description>
		A often used operation with the DataTable API is to perform an operation on a collection of cells - a common action is performed on each cell, such as adding event handlers, updating data, etc. This iteration of the cells can be performed a number of ways in DataTables, each with its own advantages:

		* `dt-api cells().every()`
		* `dt-api iterator()`
		* `dt-api each()`

		This `dt-api cells().every()` method is likely to be the most useful in the majority of cases as it sets the context of the callback function to be the `dt-api cell()` instance for the cell in question (normally a callback in the DataTables API has its context set to be at the top level API hierarchy). In simple terms this means you have the methods such as `dt-api cell().data()` available as `this.data()` in the callback given to this method.

		Consider the following example using `dt-api each()`, which iterates over the cell indexes that have been selected - we are required to get the `dt-api cell()` object for each cell to be able to work with it directly:

		```js
		table.cells().eq(0).each( function ( index ) {
			var cell = table.cell( index );

			var data = cell.data();
			// ... do something with data(), or cell.node(), etc
		} );
		```

		Using `dt-api cells().every()` this can be rewritten as:

		```js
		table.cells().every( function () {
			var data = this.data();
			// ... do something with data(), or this.node(), etc
		} );
		```

		Although a relatively simple optimisation in terms of code presentation, it can make the code much more readable and intuitive.

		The other advantage is that the table context is automatically handled - in the first example above where `dt-api each()` is used, the `dt-api eq()` method is used to select the information from the first table in the API's context only, introducing complexity if multiple tables are used. In `dt-api cells().every()` the table context is automatically set to the appropriate table for each cell that has been selected.
	</description>

	<example title="Add a class to cells which meet a logical requirement in the source data"><![CDATA[
var table = $('#example').DataTable();

table.cells().every( function () {
	if ( this.data() > 50 ) {
		$(this.node()).addClass( 'warning' );
	}
	else {
		$(this.node()).removeClass( 'warning' );
	}
} );

]]></example>


	<related type="api">columns().every()</related>
	<related type="api">each()</related>
	<related type="api">iterator()</related>
	<related type="api">rows().every()</related>
</dt-api>