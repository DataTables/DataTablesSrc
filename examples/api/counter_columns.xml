<?xml version="1.0" encoding="UTF-8" ?>
<dt-example table-type="html-index" order="9">

<css lib="datatables" />
<js lib="jquery" />
<js lib="datatables" />

<title>Index column</title>

<js><![CDATA[
var table = $('#example').DataTable({
	columnDefs: [
		{
			searchable: false,
			orderable: false,
			targets: 0
		}
	],
	order: [[1, 'asc']],
	on: {
		draw: function (e) {
			let start = e.dt.page.info().start;

			e.dt.column(0, {page: 'current'})
				.nodes()
				.each(function (cell, i) {
					cell.textContent = start + i + 1;
				});
		}
	}
});
]]></js>

<js-vanilla><![CDATA[
const table = new DataTable('#example', {
	columnDefs: [
		{
			searchable: false,
			orderable: false,
			targets: 0
		}
	],
	order: [[1, 'asc']],
	on: {
		draw: (e) => {
			let start = e.dt.page.info().start;

			e.dt.column(0, {page: 'current'})
				.nodes()
				.each((cell, i) => {
					cell.textContent = start + i + 1;
				});
		}
	}
});
]]></js-vanilla>

<info><![CDATA[

Highly-interactive tables often require a 'counter' column that contains the position for each row in the table. This column should not be sortable, and will change dynamically as the ordering and searching applied to the table is altered by the end user.

This example shows how this can be achieved with DataTables, where the first column is the counter column, and the cells are updated whenever the table is drawn to show their index location in the current filtering set. Only the rows that are displayed are updated to help improve performance in large data sets.

This is done by using `-init on` to add a `-event draw` event handler when the table starts up and then `-api column().nodes()` is used to get all of the -tag td` elements and `-api every()` to loop over them an update the display.

Note that since this is applied only to the displayed cells, we need to take account of the paging offset, which is done with the `start` property from `-api page.info()`.

]]></info>

</dt-example>
